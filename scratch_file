
# class AttributeTuple:
#     def __init__(self, node_type, node_name, node_value):
#         self.node_type = node_type
#         self.node_name = node_name
#         self.node_value = node_value
#
#
# class AttributeNode(PolarNode):
#
#     @strictly_typed
#     def __init__(self, node_type: OneOfString(['title', 'splitter', 'value']), node_name: str = '',
#                  node_value: Any = None) -> None:
#         super().__init__()
#         self.content = AttributeTuple(node_type, node_name, node_value)
#
#     @property
#     def value(self):
#         return self.content.node_value
#
#     @value.setter
#     def value(self, val):
#         self.content.node_value = val
#
#
# class AttributeGraph(BasePolarGraph):
#
#     def __init__(self):
#         super().__init__()
#         self._splitters_last_nodes = []  # list[an]
#         self._associations = {}  # {(split_an, str_val): derived_an}
#
#     @strictly_typed
#     def associate(self, splitter_an: AttributeNode, splitter_str_value: str, derived_an: AttributeNode) -> None:
#         assert splitter_an in self._nodes, 'Splitter not found in nodes list'
#         assert splitter_an.content.node_type == 'splitter', 'Can be only splitter associated'
#         assert splitter_str_value in splitter_an.content.node_value, 'Splitter str-value not found in values list'
#         self._associations[(splitter_an, splitter_str_value)] = derived_an
#
#     @strictly_typed
#     def _add_node(self, an: AttributeNode, to_splitter: AttributeNode = None, associated_splitter_value: str = '',
#                   out_splitter: bool = False) -> None:
#         self._nodes.append(an)
#         if len(self._nodes) == 1:
#             return
#         last_node = self._nodes[-1]
#         if to_splitter:
#             assert to_splitter in self._nodes, 'Splitter not found in nodes'
#             if last_node != to_splitter:
#                 self._splitters_last_nodes.append(last_node)
#             an.connect_to_its_end(to_splitter)
#             self.associate(to_splitter, associated_splitter_value, an)
#         elif out_splitter:
#             for splitters_last_node in self._splitters_last_nodes:
#                 an.connect_to_its_end(splitters_last_node)
#             self._splitters_last_nodes.clear()
#         else:
#             an.connect_to_its_end(last_node)
#
#     @strictly_typed
#     def add_typed_node(self, node_type: OneOfString(['title', 'splitter', 'value']), node_name: str,
#                        to_splitter: AttributeNode = None, associated_splitter_value: str = '') -> None:
#         an = AttributeNode(node_type, node_name)
#         self._add_node(an, to_splitter, associated_splitter_value)
#
#     @strictly_typed
#     def set_node_value(self, value_name: str, value: Any) -> None:
#         node_found = False
#         for node in self._nodes:
#             if (node.content.node_type in ['value', 'splitter']) and (node.content.node_name == value_name):
#                 if node.content.node_type == 'splitter':
#                     assert isinstance(value, Iterable), 'Need iterable value for splitter'
#                     for val in value:
#                         assert type(val) == str, 'Values in splitter should be str'
#                 node.content.node_value = value
#                 return
#         assert node_found, 'Node for setting value is not found'
#
#     @strictly_typed
#     def last_splitter(self) -> Optional[AttributeNode]:
#         for node in reversed(self._nodes):
#             if node.content.node_type == 'splitter':
#                 return node
#
#     @strictly_typed
#     def switch_splitter(self, splitter_name: str, to_splitter_str_value: str) -> None:
#         node_found = False
#         for node in self._nodes:
#             if (node.content.node_type == 'splitter') and (node.content.node_name == splitter_name):
#                 node_found = True
#                 node.switch_move_branch(self._associations[(node, to_splitter_str_value)])
#         assert node_found, 'Node for setting value is not found'
#
#     @strictly_typed
#     def get_linear_list(self) -> list[AttributeTuple]:
#         pass

# --------------------- new version --------------------------------


# class PropertiesNodeType(BoundedStringSet):
#     @strictly_typed
#     def __init__(self, prop_node_type: str) -> None:
#         super().__init__([['title'], ['splitter'], ['prop']], prop_node_type)
#
#
# class AppendNodeMethod(BoundedStringSet):
#     @strictly_typed
#     def __init__(self, prop_node_type: str) -> None:
#         super().__init__([['continue_chain'], ['to_splitter_value'], ['out_splitters']], prop_node_type)
#
#
# class PropertiesCreator:
#     def __init__(self):
#         self._base_graph = BasePolarGraph()
#         self._assoc = self.base_graph.associations
#         self._last_node = self.base_graph.inf_node_pu
#         self.assoc.register_association_types(PolarNode, {'node_type': 'PropertiesNodeType',
#                                                           'str_node_name': 'str',
#                                                           'str_node_values': 'list[str]'})
#         self.assoc.register_association_types(PGMove, {'splitter_value': 'str'})
#
#     @property
#     def base_graph(self):
#         return self._base_graph
#
#     @property
#     def assoc(self):
#         return self._assoc
#
#     @property
#     def last_node(self):
#         return self._last_node
#
#     def add_prop_node(self, str_node_name: str, str_node_values: list[str] = None,
#                       prop_node_type: PropertiesNodeType = None,
#                       append_method: AppendNodeMethod = None,
#                       connect_to_splitter_name_and_value: tuple[str, str] = None):
#         if not prop_node_type:
#             prop_node_type = PropertiesNodeType('prop')
#         if not append_method:
#             append_method = AppendNodeMethod('continue_chain')
#         bg = self.base_graph
#         assoc = self.assoc
#         prop_node: Optional[PolarNode] = None
#         if append_method == 'continue_chain':
#             ni_nd = self.last_node.ni_nd
#             prop_node, _, _ = bg.insert_node_single_link(ni_nd, bg.inf_node_nd.ni_pu)
#         elif append_method == 'out_splitters':
#             prop_node = bg.insert_node_neck(bg.inf_node_nd.ni_pu)
#         elif append_method == 'to_splitter_value':
#             assert connect_to_splitter_name_and_value, 'Splitter value should be specified'
#             spl_name, spl_value = connect_to_splitter_name_and_value
#             spl: PolarNode = assoc.get_element_by_content_value(PolarNode,
#                                                                 {'node_type': PropertiesNodeType('splitter'),
#                                                                  'str_node_name': spl_name})
#             assert spl, 'Splitter not found'
#             assert spl_value in spl.associations['str_node_values'], 'Splitter value not found'
#             ni_nd = spl.ni_nd
#             prop_node, pu_link, _ = bg.insert_node_single_link(ni_nd, bg.inf_node_nd.ni_pu)
#             move: PGMove = ni_nd.get_move(pu_link)  # 'splitter_value'
#             move.associations['splitter_value'] = spl_value
#
#         prop_node.associations['node_type'] = prop_node_type
#         prop_node.associations['str_node_name'] = str_node_name
#         prop_node.associations['str_node_values'] = str_node_values
#
#         self._last_node = prop_node

# --------------------  Assoc manager --------------
    # @strictly_typed
    # def get_all_elm_cells(self, element: Union[PolarNode, PGLink, PGMove]) -> Optional[set[TypedCell]]:
    #     if element not in self.cells:
    #         return
    #     cells = set()
    #     for _, val in self.cells[element].values():
    #         cells.add(val)
    #     return cells

    # @strictly_typed
    # def get_all_elms_by_cell_content(self, element_type: Type[Union[PolarNode, PGLink, PGMove]],
    #                                  key_function: Callable,
    #                                  context: str,
    #                                  given_elements: Optional[Iterable[Union[PolarNode, PGLink, PGMove]]] = None) -> \
    #         Union[PolarNode, PGLink, PGMove]:
    #     pass
   #
    # @strictly_typed
    # def extract_sbg_content(self, extract_keys: dict[Type[Union[PolarNode, PGLink, PGMove]], Union[str, set[str]]],
    #                         subgraph: PolarGraph, ignore_empties: bool = True, expand_result: bool = True,
    #                         get_as_strings: bool = True) -> set[Any]:
    #     result = set()
    #     types_storages = {PolarNode: subgraph.nodes, PGLink: subgraph.links, PGMove: subgraph.moves}
    #     for type_ in types_storages:
    #         if type_ in extract_keys:
    #             for element in types_storages[type_]:
    #                 element_result = set()
    #                 keys_for_extraction = extract_keys[type_]
    #                 if type(keys_for_extraction) == str:
    #                     keys_for_extraction = {keys_for_extraction}
    #                 for key in keys_for_extraction:
    #                     if not (element.associations[key] is None):
    #                         element_result.add(element.associations[key])
    #                 if ignore_empties and not element_result:
    #                     continue
    #                 if expand_result:
    #                     assert len(element_result) <= 1, 'Cannot expand result if several elements'
    #                     element_result = element_result.pop()
    #                 if get_as_strings:
    #                     element_result = str(element_result)
    #                 result.add(element_result)
    #     return result
    #
    # ---------------------------- PGGraphMovesState -----------------------

#    class PGGraphMovesState:
#
#     @strictly_typed
#     def __init__(self, pg: BasePolarGraph) -> None:
#         self._moves: list[PGMove] = []
#         self.save_state(pg)
#
#     @strictly_typed
#     def save_state(self, pg: BasePolarGraph) -> None:
#         for pn in pg.nodes:
#             ni_nd, ni_pu = pn.ni_nd, pn.ni_pu
#             nd_active_move, pu_active_move = ni_nd.active_move, ni_pu.active_move
#             if nd_active_move:
#                 self._moves.append(ni_nd.active_move)
#             if pu_active_move:
#                 self._moves.append(ni_pu.active_move)
#
#     @strictly_typed
#     def reset_state(self) -> None:
#         for move in self._moves:
#             move.ni.choice_move_activate(move)

# ---------------------------------- str to obj ------------------------

# @strictly_typed
# def str_to_obj(str_value: str, req_cls_str: str) -> tuple[Any, bool]:
#     success = True
#
#     if not str_value or str_value.isspace():
#         return None, success
#
#     req_cls = get_class_by_str(req_cls_str)
#
#     if req_cls == str:
#         return str_value, success
#
#     if req_cls and issubclass(req_cls, BoundedStringSet):
#         if str_value in req_cls.possible_strings:
#             return req_cls(str_value), success
#         else:
#             return str_value, not success
#
#     str_with_replaced_id = str_value
#     found_identifier_candidates = re.findall(r'\w+', str_value)
#     for fic in found_identifier_candidates:
#         if fic in GNM.name_to_obj:
#             str_with_replaced_id = str_with_replaced_id.replace(fic, 'GNM.name_to_obj["{}"]'.format(fic))
#     try:
#         obj = eval(str_with_replaced_id)
#     except NameError:
#         return str_value, not success
#     else:
#         if type_verification(req_cls_str, obj):
#             return obj, success
#         else:
#             return str_value, not success
#
#
# def obj_to_str(obj) -> str:
#     if obj is None:
#         return ''
#
#     if type(obj) == type:
#         return obj.__name__
#
#     return str(obj)

# ----------------------  edit focus ----------

# value_wgt_0.ed
# value_wgt_0.setValidator(AlwaysTrueValidator())
# print('valid', value_wgt_0.validator())
# value_wgt_0.focusOutEvent.connect(self.edit_finished)
# value_wgt_0.editingFinished.connect(self.edit_finished)

from PyQt5.QtGui import QValidator
class AlwaysTrueValidator(QValidator):
    def validate(self, s: str = '', i: int = 0):
        return QValidator.Acceptable

# ----------------------  line_edit  ----------

    # def get_line_edit(self, str_name: str) -> QLineEdit:
    #     for line_edit_widget, label_widget in self.widgets_dict.items():
    #         if label_widget.text() == str_name:
    #             return line_edit_widget
    #     print('Not found')
    #     assert False, 'Not found'
    #
    # def replace_line_edit(self, af: AttributeFormat):
    #     str_name = af.attr_name
    #     old_le = self.get_line_edit(str_name)
    #     new_le = QLineEdit(af.attr_value, self)
    #     self.set_bool_color(new_le, af)
    #     self.main_layout.replaceWidget(old_le, new_le)
    #     self.widgets_dict[new_le] = self.widgets_dict[old_le]
    #     self.widgets_dict.pop(old_le)
    #     old_le.setParent(None)

    # @pyqtSlot(AttributeFormat)
    # def replace_line_edit(self, af: AttributeFormat):
    #     self.attributes_column.replace_line_edit(af)

# ------------------------------------ NameDescriptor --------------------

# class NameDescriptor:
#
#     def __init__(self, start_index=1):
#         assert type(start_index) == int, 'Start index must be int'
#         self.start_index = start_index
#
#     def __get__(self, instance, owner=None):
#
#         if not (instance is None) and not hasattr(instance, '_name'):
#             instance._name = None
#
#         if instance is None:
#             return owner.__name__
#         else:
#             if not (instance._name is None):
#                 return instance._name
#             else:
#                 raise ValueError('Name is not defined')
#
#     def __set__(self, instance, name_candidate):
#         if hasattr(instance, '_name'):
#             GNM.remove_obj_name(instance)
#         prefix = instance.__class__.__name__ + '_'
#         if name_candidate == 'auto_name':
#             i = self.start_index
#             while True:
#                 if i < 1:
#                     name_candidate = '{}{}'.format(prefix, '0' * (1 - i))
#                 else:
#                     name_candidate = '{}{}'.format(prefix, i)
#                 if GNM.check_new_name(name_candidate):
#                     break
#                 else:
#                     i += 1
#         else:
#             assert type(name_candidate) == str, 'Name need be str'
#             assert bool(re.fullmatch(r'\w+', name_candidate)), 'Name have to consists of alphas, nums and _'
#             assert name_candidate.startswith(prefix), 'Name have to begin from className_'
#             assert name_candidate != prefix, 'name cannot be == prefix; add specification to end'
#             assert not name_candidate[
#                        len(prefix):].isdigit(), 'Not auto-name cannot be (prefix + int); choose other name'
#             assert GNM.check_new_name(name_candidate), 'Name {} already exists'.format(name_candidate)
#         instance._name = name_candidate
#         GNM.register_obj_name(instance, name_candidate)

# -------------------- From Cell ------------

# def default_syntax_checker(value: str) -> Any:
#     value_got = value
#     found_identifier_candidates = re.findall(r'\w+', value)
#     for fic in found_identifier_candidates:
#         if fic in GNM.name_to_obj:
#             value = value.replace(fic, 'GNM.name_to_obj["{}"]'.format(fic))
#     try:
#         eval_result = eval(value)
#     except SyntaxError:
#         raise SyntaxCellError('Syntax error when parsing ' + value_got)
#     except NameError:
#         raise SyntaxCellError('Name error when parsing ' + value_got)
#     else:
#         return eval_result
#
#
# def splitter_syntax_checker(value: str, cls: type):
#     if value not in cls.possible_strings:
#         raise SyntaxCellError('Value of splitter not in possible values{}'.format(cls.possible_strings))
#     return value
#
#
# def bool_syntax_checker(value: str, cls: type):
#     if value not in cls.possible_strings:
#         raise SyntaxCellError('Value of splitter not in possible values {}'.format(cls.possible_strings))
#     return eval(value)
#
#
# def name_syntax_checker(value: str, obj: Any) -> str:
#     cls = obj.__class__
#     if (obj in GNM.obj_to_name) and (value == GNM.obj_to_name[obj]):
#         return value
#     prefix = cls.__name__ + '_'
#     if not re.fullmatch(r'\w+', value):
#         raise SyntaxCellError('Name have to consists of alphas, nums and _')
#     if not value.startswith(prefix):
#         raise SyntaxCellError('Name have to begin from ClassName_')
#     if value == prefix:
#         raise SyntaxCellError('Name cannot be == prefix; add specification to end')
#     if not GNM.check_new_name(value):
#         raise SyntaxCellError('Name {} already exists'.format(value))
#     return value
#
#
# def default_type_checker(value: Any, req_cls_str: str) -> None:
#     if not type_verification(req_cls_str, value):
#         raise TypeCellError('Given str_value type is not equal to required type')


# class CellChecker:
#     def __init__(self, f_check_syntax=None, f_check_type=None, f_check_semantic_list: list = None):
#         self.f_check_syntax = f_check_syntax
#         self.f_check_type = f_check_type
#         if f_check_semantic_list is None:
#             self.f_check_semantic_list = []
#         else:
#             self.f_check_semantic_list = f_check_semantic_list
#         self._req_class_str = None
#
#     def add_semantic_checker(self, f_check_semantic: Callable):
#         self.f_check_semantic_list.append(f_check_semantic)
#
#     def check_value(self, str_value: str):
#         result = None
#         if self.f_check_syntax:
#             result = self.f_check_syntax(str_value)
#         if self.f_check_type:
#             self.f_check_type(result)
#         for f_check_semantic in self.f_check_semantic_list:
#             f_check_semantic(str_value, result)
#         return result
#
#     @property
#     def req_class_str(self):
#         return self._req_class_str
#
#
# class NameCellChecker(CellChecker):
#     def __init__(self, obj: Any):
#         super().__init__(partial(name_syntax_checker, obj=obj))
#         self._req_class_str = 'str'  # .format(cls.__name__)
#
#
# class SplitterCellChecker(CellChecker):
#     def __init__(self, cls: type):
#         super().__init__(partial(splitter_syntax_checker, cls=cls))
#         self._req_class_str = cls.__name__
#
#
# class BoolCellChecker(CellChecker):
#     def __init__(self, cls: type):
#         super().__init__(partial(bool_syntax_checker, cls=cls))
#         self._req_class_str = cls.__name__
#
#
# class DefaultCellChecker(CellChecker):
#     def __init__(self, req_cls_str: str):
#         super().__init__(default_syntax_checker, partial(default_type_checker, req_cls_str=req_cls_str))
#         self._req_class_str = req_cls_str
#
#
# def name_auto_setter(cls: Any, start_index: int = 1):
#     prefix = cls.__name__ + '_'
#     i = start_index
#     while True:
#         if i < 1:
#             auto_name = '{}{}'.format(prefix, '0' * (1 - i))
#         else:
#             auto_name = '{}{}'.format(prefix, i)
#         if GNM.check_new_name(auto_name):
#             break
#         else:
#             i += 1
#     # print('In auto_name', auto_name)
#     return auto_name
#
#
# class AutoValueSetter:
#     def __init__(self, f_set_function=None):
#         self.f_set_function = f_set_function
#
#     def get_auto_value(self):  # , *args, **kwargs
#         return self.f_set_function()  # *args, **kwargs
#
#
# class NameAutoSetter(AutoValueSetter):
#     def __init__(self, cls: Any, start_index: int = 1):
#         super().__init__(partial(name_auto_setter, cls=cls, start_index=start_index))

        # self._is_suggested_value = False
        # self._str_value = val
        # if val == '':
        #     self._status_check = 'empty'


    # def activate(self):
    #     if self.str_value == '':
    #         self.auto_set_value()
    #     self._active = True
    #
    # def deactivate(self):
    #     self._active = False

    # @property
    # def checker(self):
    #     return self._checker
    #
    # @property
    # def auto_setter(self):
    #     return self._auto_setter


    # def check_value(self):
    #     if self.str_value == '':
    #         self._status_check = 'empty'
    #         self._value = None
    #         return
    #     if self.checker:
    #         try:
    #             result = self.checker.check_value(self.str_value)
    #         except CellError as ce:
    #             self._status_check = ce.args[0]
    #             self._value = None
    #         else:
    #             self._status_check = ''
    #             self._value = result
    #     else:
    #         self._status_check = ''
    #         self._value = self.str_value
    #
    # def auto_set_value(self):
    #     if self.auto_setter:
    #         self.str_value = self.auto_setter.get_auto_value()
    #         self.check_value()
    #         self._is_suggested_value = True

    # @property
    # def req_class_str(self):
    #     if self.checker:
    #         return self.checker.req_class_str


# if __name__ == '__main__':
#     class A:
#         pass


    a = A()
    # cc_1 = CellChecker(partial(name_syntax_checker, cls=A))
    # cc_2 = CellChecker(default_syntax_checker, partial(default_type_checker, req_cls_str='str'))
    # cc_1 = NameCellChecker(A)
    # cc_2 = DefaultCellChecker('int')
    # print(cc_1.check_value("A_r"))
    # print(cc_2.check_value("13"))
    # nas = NameAutoSetter(A)
    # GNM.register_obj_name('A_1', a)
    # print(nas.get_auto_value())

    # tc = TypedCell('tc', 'str', '13')
    # print(tc.__dict__)

# -----------------------------------  Messages Manager ------------
# from PyQt5.QtWidgets import QMessageBox
# from PyQt5.QtCore import QObject, pyqtSlot
# class MessagesManager(QObject):
#     def __init__(self, mw):
#         super().__init__()
#         self.mw = mw
#
#     @pyqtSlot(str)
#     def info_message(self, val):
#         QMessageBox.about(self.mw, "Title", val)

# --------------------------------  Layout cleaning ----------------

        # self.main_layout = QVBoxLayout()
        # self.setLayout(self.main_layout)
        # self.widgets_dict: dict[QWidget, QWidget] = {}

        # layout_stack = [self.main_layout]
        # while layout_stack:
        #     current_layout = layout_stack.pop()
        #     count = current_layout.count()
        #     wgts = set()
        #     for index in range(count):
        #         item = current_layout.itemAt(index)
        #         if isinstance(item, QLayout):
        #             layout_stack.append(item)
        #         elif isinstance(item, QWidgetItem):
        #             wgt = item.widget()
        #             wgts.add(wgt)
        #         else:
        #             assert False, 'Other variants'
        #     for wgt in wgts:
        #         wgt.setParent(None)
        #     if not (current_layout is self.main_layout):
        #         current_layout.setParent(None)


# class BaseDescriptor:
#     """ Contains single value or list of values """
#
#     def __init__(self, is_list: bool = False, count_requirement: int = 1, is_min_count: bool = False):
#         self.is_list = is_list
#         self.count_requirement = count_requirement
#         self.is_min_count = is_min_count
#
#     def __set_name__(self, owner, name):
#         self.name = name
#
#     def __get__(self, instance, owner):
#         if not instance:
#             return self
#
#         # elif hasattr(instance, "_{}".format(self.name)):
#         #     return getattr(instance, "_{}".format(self.name))
#         # else:
#         #     if self.count_requirement == 1:
#         #         setattr(instance, "_{}".format(self.name), "")
#         #         setattr(instance, "_str_{}".format(self.name), "")
#         #         setattr(instance, "_check_status_{}".format(self.name), "")
#         #     elif self.count_requirement == -1:
#         #         setattr(instance, "_{}".format(self.name), [""] * 1)
#         #         setattr(instance, "_str_{}".format(self.name), [""] * 1)
#         #         setattr(instance, "_check_status_{}".format(self.name), [""] * 1)
#         #     else:
#         #         setattr(instance, "_{}".format(self.name), [""] * self.count_requirement)
#         #         setattr(instance, "_str_{}".format(self.name), [""] * self.count_requirement)
#         #         setattr(instance, "_check_status_{}".format(self.name), [""] * self.count_requirement)
#         #     return getattr(instance, "_{}".format(self.name))
#
#     def __set__(self, instance: StationObjectImage, value: Union[str, list[str]]):
#         setattr(instance, "_str_" + self.name, value)
#
#
# class IntTypeDescriptor(BaseDescriptor):
#     """ Contains standard value as int, float, str """
#
#     def __init__(self, count_requirement: int = 1):
#         super().__init__(count_requirement)
#
#     def __set__(self, instance: StationObjectImage, input_value: Union[str, list[str]]):
#         super().__set__(instance, input_value)
#         if isinstance(input_value, str):
#             input_value = input_value.strip()
#         else:
#             input_value = [val.strip() for val in input_value]
#         if isinstance(input_value, str):
#             if input_value.isdigit() and (self.count_requirement == 1):
#                 setattr(instance, "_" + self.name, input_value)
#                 setattr(instance, "_check_status_" + self.name, "")
#             else:
#                 setattr(instance, "_check_status_" + self.name, "Value {} is not single int".format(input_value))
#         else:
#             if not hasattr(instance, "_{}".format(self.name)):
#                 if self.count_requirement == -1:
#                     setattr(instance, "_{}".format(self.name), [""] * 1)
#                 else:
#                     setattr(instance, "_{}".format(self.name), [""] * self.count_requirement)
#             old_destination_list = getattr(instance, "_{}".format(self.name))
#             destination_list = []
#             check_list = []
#             for i, value in enumerate(input_value):
#                 destination_list.append("")
#                 check_list.append("")
#                 if value.isdigit():
#                     destination_list[-1] = value
#                     check_list[-1] = ""
#                 else:
#                     check_list[-1] = "Value {} is not int".format(value)
#                     if i < len(old_destination_list):
#                         destination_list[i] = old_destination_list[i]
#             setattr(instance, "_{}".format(self.name), destination_list)
#             setattr(instance, "_check_status_{}".format(self.name), check_list)
#
#
# class BoundedSetOfValuesDescriptor(BaseDescriptor):
#
#     def __init__(self, count_requirement: int = 1):
#         super().__init__(count_requirement)
#         self._possible_values = []
#
#     def __set__(self, instance: StationObjectImage, input_value: Union[str, list[str]]):
#         super().__set__(instance, input_value)
#         if isinstance(input_value, str):
#             input_value = input_value.strip()
#         else:
#             input_value = [val.strip() for val in input_value]
#         if isinstance(input_value, str):
#             if (input_value in self.possible_values) and (self.count_requirement == 1):
#                 setattr(instance, "_" + self.name, input_value)
#                 setattr(instance, "_check_status_" + self.name, "")
#             else:
#                 setattr(instance, "_check_status_" + self.name,
#                         "Value {} not in list of possible values: {}".format(input_value, self.possible_values))
#         else:
#             if not hasattr(instance, "_{}".format(self.name)):
#                 if self.count_requirement == -1:
#                     setattr(instance, "_{}".format(self.name), [""] * 1)
#                 else:
#                     setattr(instance, "_{}".format(self.name), [""] * self.count_requirement)
#             old_destination_list = getattr(instance, "_{}".format(self.name))
#             destination_list = []
#             check_list = []
#             for i, value in enumerate(input_value):
#                 destination_list.append("")
#                 check_list.append("")
#                 if value in self.possible_values:
#                     destination_list[-1] = value
#                     check_list[-1] = ""
#                 else:
#                     check_list[-1] = "Value {} not in list of possible values: {}".format(value,
#                                                                                           self.possible_values)
#                     if i < len(old_destination_list):
#                         destination_list[i] = old_destination_list[i]
#             setattr(instance, "_{}".format(self.name), destination_list)
#             setattr(instance, "_check_status_{}".format(self.name), check_list)
#
#     @property
#     def possible_values(self) -> list[str]:
#         result = list(self._possible_values)
#         return result
#
#     @possible_values.setter
#     def possible_values(self, values: Iterable[str]):
#         self._possible_values = values


        CoordinateSystemSOI.cs_relative_to.obj_dict = self.soi_objects["CoordinateSystemSOI"].keys()

        AxisSOI.cs_relative_to.possible_values = self.soi_objects["CoordinateSystemSOI"].keys()
        AxisSOI.center_point.possible_values = self.soi_objects["PointSOI"].keys()

        PointSOI.axis.possible_values = self.soi_objects["AxisSOI"].keys()
        PointSOI.line.possible_values = self.soi_objects["LineSOI"].keys()
        PointSOI.cs_relative_to.possible_values = self.soi_objects["CoordinateSystemSOI"].keys()

        LineSOI.points.possible_values = self.soi_objects["PointSOI"].keys()

        LightSOI.center_point.possible_values = self.soi_objects["PointSOI"].keys()
        LightSOI.direct_point.possible_values = self.soi_objects["PointSOI"].keys()

        RailPointSOI.center_point.possible_values = self.soi_objects["PointSOI"].keys()
        RailPointSOI.dir_plus_point.possible_values = self.soi_objects["PointSOI"].keys()
        RailPointSOI.dir_minus_point.possible_values = self.soi_objects["PointSOI"].keys()

        BorderSOI.point.possible_values = self.soi_objects["PointSOI"].keys()

        SectionSOI.border_points.possible_values = self.soi_objects["PointSOI"].keys()



class SOIAttrSeqTemplate:
    def __get__(self, instance, owner) -> list[str]:
        return [attr_name for attr_name in owner.__dict__ if not attr_name.startswith("__")]

    def __set__(self, instance, value):
        raise NotImplementedError('{} setter not implemented'.format(self.__class__.__name__))


class SOIActiveAttrs:
    def __get__(self, instance, owner):
        assert instance, "Only for instance"
        instance: StationObjectImage
        instance._active_attrs = instance.attr_sequence_template

        if owner == CoordinateSystemSOI:
            instance: CoordinateSystemSOI
            if instance.dependence == CEDependence.independent:
                instance._active_attrs.remove(CoordinateSystemSOI.x.name)
                instance._active_attrs.remove(CoordinateSystemSOI.co_x.name)
                instance._active_attrs.remove(CoordinateSystemSOI.co_y.name)

        if owner == AxisSOI:
            instance: AxisSOI
            if instance.creation_method == CEAxisCreationMethod.rotational:
                instance._active_attrs.remove(AxisSOI.y.name)
            else:
                instance._active_attrs.remove(AxisSOI.alpha.name)
                instance._active_attrs.remove(AxisSOI.center_point.name)

        if owner == PointSOI:
            instance: PointSOI
            if instance.on == CEAxisOrLine.axis:
                instance._active_attrs.remove(PointSOI.line.name)
            else:
                instance._active_attrs.remove(PointSOI.axis.name)

        return instance._active_attrs

    def __set__(self, instance, value):
        raise NotImplementedError('{} setter not implemented'.format(self.__class__.__name__))


class SODictEnumPossibleValues:
    def __get__(self, instance, owner) -> OrderedDict[str, list[str]]:
        result = OrderedDict()
        for attr_ in owner.attr_sequence_template:
            attrib = getattr(owner, attr_)
            if attrib.enum:
                result[attr_] = attrib.enum.possible_values
        return result

    def __set__(self, instance, value):
        raise NotImplementedError('{} setter not implemented'.format(self.__class__.__name__))


class SOIListValues:
    def __get__(self, instance, owner):
        assert instance, "Only for instance"
        instance: StationObjectImage
        result = OrderedDict()
        for active_attr in instance.active_attrs:
            result[active_attr] = getattr(instance, active_attr)
        return result

    def __set__(self, instance, value):
        raise NotImplementedError('{} setter not implemented'.format(self.__class__.__name__))




    # test_3 = False
    # if test_3:
    #     pnt = PointSOI()
    #     pnt.x = "PK_12+34"
    #     print(type(pnt.x))
    #     print(pnt.x)
    #     print(PointSOI.attr_sequence_template)
    #
    # test_4 = False
    # if test_4:
    #     cs = CoordinateSystemSOI()
    #     print(CoordinateSystemSOI.dict_possible_values)
    #     print(cs.dict_possible_values)
    #
    # test_5 = False
    # if test_5:
    #     make_xlsx_templates(STATION_OUT_CONFIG_FOLDER)
    #
    # test_6 = False
    # if test_6:
    #     objs = read_station_config(STATION_IN_CONFIG_FOLDER)
    #     # pnt = get_object_by_name("Point_15", objs)
    #     print(pnt.dict_possible_values)
    #     print(pnt.__class__.dict_possible_values)
    #     # for attr_ in pnt.active_attrs:
    #     #     print(getattr(pnt, attr_))
    #
    # test_7 = False
    # if test_7:
    #     pnt = PointSOI()
    #     pnt.x = "PK_12+34"
    #     print(pnt.x)
    #
    # test_8 = False
    # if test_8:
    #     objs = read_station_config(STATION_IN_CONFIG_FOLDER)
    #     # SOIR.build_dg(objs)
    #     # SOIR.check_cycle()
    #     # print([obj.name for obj in SOIR.rectified_object_list()])
    #     # build_model(SOIR.rectified_object_list())
    #
    # test_9 = False
    # if test_9:
    #     execute_commands([Command(CECommand(CECommand.load_config), [STATION_IN_CONFIG_FOLDER])])
    #     print(MODEL.names_soi)
    #     print(MODEL.names_mo)
    #
    #     # cs_1: CoordinateSystemMO = MODEL.names_mo['CS_1']
    #     # print(cs_1.absolute_x)
    #     # print(cs_1.absolute_y)
    #     # print(cs_1.absolute_co_x)
    #     # print(cs_1.absolute_co_y)
    #     # if 'CS_2' in MODEL.names_mo:
    #     #     cs_2 = MODEL.names_mo['CS_2']
    #     #     print(cs_2.absolute_x)
    #     #     print(cs_2.absolute_y)
    #     #     print(cs_2.absolute_co_x)
    #     #     print(cs_2.absolute_co_y)
    #     # if 'CS_3' in MODEL.names_mo:
    #     #     cs_3 = MODEL.names_mo['CS_3']
    #     #     print(cs_3.absolute_x)
    #     #     print(cs_3.absolute_y)
    #     #     print(cs_3.absolute_co_x)
    #     #     print(cs_3.absolute_co_y)
    #
    #     ax_1: AxisMO = MODEL.names_mo['Axis_1']
    #     print(ax_1.line2D)
    #
    #     line_2: LineMO = MODEL.names_mo['Line_7']
    #     print(line_2.boundedCurves)
    #
    #     # pnt_15: PointMO = MODEL.names_mo['Axis_1']
    #     # print(ax_1.line2D)
    #
    # test_10 = False
    # if test_10:
    #
    #     execute_commands([Command(CECommand(CECommand.load_config), [STATION_IN_CONFIG_FOLDER])])
    #     print(MODEL.names_soi)
    #     # print(MODEL.names_soi.keys())  # .rect_so
    #     print(MODEL.rect_so)
    #     print(MODEL.names_mo)
    #
    #     # line_1_node = get_point_node_DG("Line_1")
    #     # line_6_node = get_point_node_DG("Line_6")
    #     # point_16_node = get_point_node_DG("Point_16")
    #     # print("line_1_node", line_1_node)
    #     # print("line_6_node", line_6_node)
    #     # print("line_6 up connections", [link.opposite_ni(line_6_node.ni_pu).pn for link in line_6_node.ni_pu.links])
    #     # print("point_16_node", point_16_node)
    #     # print("point_16 up connections", [link.opposite_ni(point_16_node.ni_pu).pn
    #     for link in point_16_node.ni_pu.links])
    #     #
    #     # print(MODEL.dg.longest_coverage())
    #     # print("len routes", len(MODEL.dg.walk(MODEL.dg.inf_pu.ni_nd)))
    #     # i=0
    #     # for route in MODEL.dg.walk(MODEL.dg.inf_pu.ni_nd):
    #     #     if (line_6_node in route.nodes) or (line_6_node in route.nodes):
    #     #         i+=1
    #     #         print("i=", i)
    #     #         print("nodes", route.nodes)
    #
    #     # ax_1: AxisMO = MODEL.names_mo['Axis_2']
    #     # print([pnt.x for pnt in ax_1.points])
    #     print(len(MODEL.smg.not_inf_nodes))
    #
    #     print("minus inf", MODEL.smg.inf_nd)
    #     print("plus inf", MODEL.smg.inf_pu)
    #     for i in range(20):
    #         try:
    #             pnt_name = "Point_{}".format(str(i+1))
    #             pnt_node: PolarNode = find_cell_name(MODEL.smg.not_inf_nodes, PointCell, pnt_name)[1]
    #             print(pnt_name+" =>", pnt_node)
    #             print("nd-connections", [link.opposite_ni(pnt_node.ni_nd).pn for link in pnt_node.ni_nd.links])
    #             print("pu-connections", [link.opposite_ni(pnt_node.ni_pu).pn for link in pnt_node.ni_pu.links])
    #         except NotFoundCellError:
    #             continue
    #     print("len of links", len(MODEL.smg.links))
    #     for link in MODEL.smg.not_inf_links:
    #         print()
    #         ni_s = link.ni_s
    #         pn_s = [ni.pn for ni in link.ni_s]
    #         pnt_cells: list[PointCell] = [element_cell_by_type(pn, PointCell) for pn in pn_s]
    #         print("link between {}, {}".format(pnt_cells[0].name, pnt_cells[1].name))
    #         print("length {}".format(element_cell_by_type(link, LengthCell).length))
    #         for ni in ni_s:
    #             move = ni.get_move_by_link(link)
    #             if move.cell_objs:
    #                 rpdc = element_cell_by_type(move, RailPointDirectionCell)
    #                 print("Rail point direction = ", rpdc.direction)
    #         print("section {}".format(element_cell_by_type(link, IsolatedSectionCell).name))
    #
    # test_11 = False
    # if test_11:
    #     execute_commands([Command(CECommand(CECommand.load_config), [STATION_IN_CONFIG_FOLDER])])
    #     light_cells = all_cells_of_type(MODEL.smg.not_inf_nodes, LightCell)
    #     print(len(light_cells))

    test_12 = False
    if test_12:
        pass
        # execute_commands([Command(CECompositeCommand(CECompositeCommand.load_from_file), [STATION_IN_CONFIG_FOLDER])])
        # MODEL.eval_routes("TrainRoute.xml", "ShuntingRoute.xml")

    test_13 = False
    if test_13:
        pass
        # class Command:
        #     def __init__(self, name: str):
        #         self.name = name
        #
        #     def __repr__(self):
        #         return "{}('{}')".format(self.__class__.__name__, self.name)
        #
        #     __str__ = __repr__

        # cmd_sup = CommandSupervisor()
        # cmd_sup.save_state(SOI_IS)
        # print("pointer = ", cmd_sup.command_pointer)
        # cmd_sup.continue_commands(Command("1"))
        # print("pointer = ", cmd_sup.command_pointer)
        # cmd_sup.continue_commands(Command("2"))
        # print("pointer = ", cmd_sup.command_pointer)
        # cmd_sup.save_state(SOI_IS)
        # print("pointer = ", cmd_sup.command_pointer)
        # cmd_sup.continue_commands(Command("3"))
        # print("pointer = ", cmd_sup.command_pointer)
        # cmd_sup.continue_commands(Command("4"))
        # print("pointer = ", cmd_sup.command_pointer)
        # print([command_chain.cmd_chain for command_chain in cmd_sup.command_chains])
        # cmd_sup.undo()
        # print()
        # cmd_sup.undo()
        # print()
        # cmd_sup.undo()
        # print()
        # cmd_sup.undo()
        # print()
        # cmd_sup.undo()
        # print()
        # cmd_sup.undo()
        # print()
        # cmd_sup.continue_commands(Command("5"))
        # print("pointer = ", cmd_sup.command_pointer)
        # print([command_chain.cmd_chain for command_chain in cmd_sup.command_chains])

    # def execute_commands(self):
    #     last_command = False
    #     if self.command_pointer:
    #         for chain in self.command_chains:
    #             if chain.index_command_in_chain(self.command_pointer) == -1:
    #                 continue
    #             for command in chain.cmd_chain:
    #                 old_images = self.soi_iast.copied_soi_objects
    #                 new_images = self.execute_command(command)
    #                 if command is self.command_pointer:
    #                     self.apply_readiness = False
    #                     if (command.cmd_type == CECommand.load_from_file) or \
    #                             (command.cmd_type == CECommand.load_after_deletion):
    #                         self.model.rectifier.batch_load_mode = True
    #                         try:
    #                             self.model_building(new_images)
    #                         except (DependenciesBuildError, AttributeEvaluateError) as e:
    #                             cls_name, obj_name, attr_name, comment = e.args
    #                             self.error_handler(cls_name, obj_name, attr_name, comment)
    #                             self.model_building(old_images)
    #                         except ModelBuildError as e:
    #                             cls_name, obj_name, comment = e.args
    #                             self.error_handler(cls_name, obj_name, "", comment)
    #                             self.model_building(old_images)
    #                         else:
    #                             self.new_stable_images = new_images
    #                             self.apply_readiness = True
    #                             self.apply_changes()
    #                             self.soi_iast.reset_current_object()
    #                         finally:
    #                             self.model.rectifier.batch_load_mode = False
    #                     else:
    #                         try:
    #                             self.model_building(new_images)
    #                         except (DependenciesBuildError, AttributeEvaluateError) as e:
    #                             cls_name, obj_name, attr_name, comment = e.args
    #                             self.error_handler(cls_name, obj_name, attr_name, comment)
    #                         except ModelBuildError as e:
    #                             cls_name, obj_name, comment = e.args
    #                             self.error_handler(cls_name, obj_name, "", comment)
    #                         else:
    #                             self.new_stable_images = new_images
    #                             self.apply_readiness = True
    #                         finally:
    #                             self.model_building(old_images)
    #                     last_command = True
    #                     break
    #             if last_command:
    #                 break



-----------------------  tests ----------------------------------


    test_14 = False
    if test_14:
        cmd_sup = CommandSupervisor()
        cmd_sup.read_station_config(STATION_IN_CONFIG_FOLDER)
        cmd_sup.read_station_config(STATION_IN_CONFIG_FOLDER)
        cmd_sup.undo()
        # cmd_sup.undo()
        print("command_pointer", cmd_sup.command_pointer)
        print([command_chain.commands for command_chain in cmd_sup.command_chains])
        cmd_sup.eval_routes("TrainRoute.xml", "ShuntingRoute.xml")

    test_15 = False
    if test_15:
        cmd_sup = CommandSupervisor()
        cmd_sup.create_new_object("CoordinateSystemSOI")
        # cmd_sup.create_new_object("AxisSOI")
        # cmd_sup.create_new_object("LineSOI")
        curr_obj = cmd_sup.soi_iast.current_object
        curr_obj.x = "5"
        print(curr_obj)
        print(curr_obj._str_x)
        cmd_sup.undo()
        curr_obj_after_undo = cmd_sup.soi_iast.current_object
        print()
        print(curr_obj_after_undo)

    test_16 = False
    if test_16:
        cmd_sup = CommandSupervisor()
        cmd_sup.create_new_object("CoordinateSystemSOI")
        cmd_sup.change_attribute_value("x", "5")
        curr_obj = cmd_sup.soi_iast.current_object
        print(curr_obj)
        print(curr_obj._str_x)

    test_17 = False
    if test_17:
        # print(cmd_sup.soi_iast.current_object.__dict__)
        cmd_sup = CommandSupervisor()
        print("create_new")
        cmd_sup.create_new_object("CoordinateSystemSOI")
        print("name")
        cmd_sup.change_attribute_value("name", "MyCS_1")
        print("cs_relative_to")
        cmd_sup.change_attribute_value("cs_relative_to", "GlobalCS")
        print("x")
        cmd_sup.change_attribute_value("x", "0")
        cmd_sup.apply_changes()

        print("create_new")
        cmd_sup.create_new_object("CoordinateSystemSOI")
        print("name")
        cmd_sup.change_attribute_value("name", "MyCS_2")
        print("cs_relative_to")
        cmd_sup.change_attribute_value("cs_relative_to", "MyCS_1")
        print("x")
        cmd_sup.change_attribute_value("x", "0")
        cmd_sup.apply_changes()

        # print("dependent", cmd_sup.model.rectifier.dependent_objects_names("MyCS_2"))
        # print("change_current_object")
        # cmd_sup.change_current_object("MyCS_1")
        # print("cs_relative_to")
        # cmd_sup.change_attribute_value("cs_relative_to", "MyCS_2")
        # cmd_sup.apply_changes()

        # cmd_sup.delete_confirmed("MyCS_2")
        # cmd_sup.deletion_approved()

        print("change_current_object")
        cmd_sup.change_current_object("MyCS_1")
        print("name")
        cmd_sup.change_attribute_value("name", "MyCS_0")
        cmd_sup.apply_changes()

        print("names", [obj.name for obj in cmd_sup.soi_iast.soi_objects])
        MyCS_2 = cmd_sup.soi_iast.get_obj_by_name("MyCS_2")
        print("MyCS_2 cs = ", MyCS_2.cs_relative_to.name)

        dg = cmd_sup.model.rectifier.dg
        print(len(dg.nodes))
        print(len(dg.links))
        print(dg.links)


        # route_nodes = set()
        # for route in routes:
        #     route_nodes |= set(route.nodes)
        # if len(route_nodes) < len(self.dg.nodes):
        #     nodes = self.dg.nodes - route_nodes
        #     """ find groups of isolated nodes """
        #     node_groups = []
        #     nodes_included = set()
        #     ad_list = []
        #     for node in nodes:
        #         if node not in nodes_included:
        #             local_route_nodes = set()
        #             local_routes = self.dg.walk(node.ni_nd)
        #             for local_route in local_routes:
        #                 local_route_nodes |= set(local_route.nodes)
        #             node_groups.append(local_route_nodes)
        #             nodes_included |= local_route_nodes
        #     for node_group in node_groups:
        #         cells = [element_cell_by_type(node, ObjNodeCell) for node in node_group]
        #         cls_obj_names = [(cell.cls_name, cell.obj_name) for cell in cells]
        #         for cell in cells:
        #             parent_cls_name = cell.cls_name
        #             parent_obj_name = cell.obj_name
        #             tca_tuple_list = self.to_child_attribute_dict[parent_cls_name][parent_obj_name]
        #             child_obj, child_attr_name, child_attr_index = None, None, None
        #             for tca_tuple in tca_tuple_list:
        #                 obj = tca_tuple[0]
        #                 if (obj.__class__.__name__, obj.name) in cls_obj_names:
        #                     child_obj, child_attr_name, child_attr_index = tca_tuple
        #                     break
        #             assert child_obj
        #             ad_list.append(AttributeData(child_obj.__class__.__name__, child_obj.name,
        #                                          child_attr_name, child_attr_index))
        #     raise DBIsolatedNodesError("Isolated cycles in dependencies was found", ad_list)
            # obj_names: list[str] = [(cell.cls_name, cell.obj_name) for cell in cells]
            # raise DBIsolatedNodesError("Isolated cycles in dependencies was found",
            #                            [AttributeData(cls_name, obj_name, "") for cls_name, obj_name in obj_names])


                # cells: list[str] = [element_cell_by_type(node, ObjNodeCell) for node in route_.cycle_nodes]
                # obj_names: list[str] = [(cell.cls_name, cell.obj_name) for cell in cells]
                # raise DBCycleError("Cycle in dependencies was found",
                #                    [AttributeData(cls_name, obj_name, "") for cls_name, obj_name in obj_names])

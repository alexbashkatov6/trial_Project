
# class AttributeTuple:
#     def __init__(self, node_type, node_name, node_value):
#         self.node_type = node_type
#         self.node_name = node_name
#         self.node_value = node_value
#
#
# class AttributeNode(PolarNode):
#
#     @strictly_typed
#     def __init__(self, node_type: OneOfString(['title', 'splitter', 'value']), node_name: str = '',
#                  node_value: Any = None) -> None:
#         super().__init__()
#         self.content = AttributeTuple(node_type, node_name, node_value)
#
#     @property
#     def value(self):
#         return self.content.node_value
#
#     @value.setter
#     def value(self, val):
#         self.content.node_value = val
#
#
# class AttributeGraph(BasePolarGraph):
#
#     def __init__(self):
#         super().__init__()
#         self._splitters_last_nodes = []  # list[an]
#         self._associations = {}  # {(split_an, str_val): derived_an}
#
#     @strictly_typed
#     def associate(self, splitter_an: AttributeNode, splitter_str_value: str, derived_an: AttributeNode) -> None:
#         assert splitter_an in self._nodes, 'Splitter not found in nodes list'
#         assert splitter_an.content.node_type == 'splitter', 'Can be only splitter associated'
#         assert splitter_str_value in splitter_an.content.node_value, 'Splitter str-value not found in values list'
#         self._associations[(splitter_an, splitter_str_value)] = derived_an
#
#     @strictly_typed
#     def _add_node(self, an: AttributeNode, to_splitter: AttributeNode = None, associated_splitter_value: str = '',
#                   out_splitter: bool = False) -> None:
#         self._nodes.append(an)
#         if len(self._nodes) == 1:
#             return
#         last_node = self._nodes[-1]
#         if to_splitter:
#             assert to_splitter in self._nodes, 'Splitter not found in nodes'
#             if last_node != to_splitter:
#                 self._splitters_last_nodes.append(last_node)
#             an.connect_to_its_end(to_splitter)
#             self.associate(to_splitter, associated_splitter_value, an)
#         elif out_splitter:
#             for splitters_last_node in self._splitters_last_nodes:
#                 an.connect_to_its_end(splitters_last_node)
#             self._splitters_last_nodes.clear()
#         else:
#             an.connect_to_its_end(last_node)
#
#     @strictly_typed
#     def add_typed_node(self, node_type: OneOfString(['title', 'splitter', 'value']), node_name: str,
#                        to_splitter: AttributeNode = None, associated_splitter_value: str = '') -> None:
#         an = AttributeNode(node_type, node_name)
#         self._add_node(an, to_splitter, associated_splitter_value)
#
#     @strictly_typed
#     def set_node_value(self, value_name: str, value: Any) -> None:
#         node_found = False
#         for node in self._nodes:
#             if (node.content.node_type in ['value', 'splitter']) and (node.content.node_name == value_name):
#                 if node.content.node_type == 'splitter':
#                     assert isinstance(value, Iterable), 'Need iterable value for splitter'
#                     for val in value:
#                         assert type(val) == str, 'Values in splitter should be str'
#                 node.content.node_value = value
#                 return
#         assert node_found, 'Node for setting value is not found'
#
#     @strictly_typed
#     def last_splitter(self) -> Optional[AttributeNode]:
#         for node in reversed(self._nodes):
#             if node.content.node_type == 'splitter':
#                 return node
#
#     @strictly_typed
#     def switch_splitter(self, splitter_name: str, to_splitter_str_value: str) -> None:
#         node_found = False
#         for node in self._nodes:
#             if (node.content.node_type == 'splitter') and (node.content.node_name == splitter_name):
#                 node_found = True
#                 node.switch_move_branch(self._associations[(node, to_splitter_str_value)])
#         assert node_found, 'Node for setting value is not found'
#
#     @strictly_typed
#     def get_linear_list(self) -> list[AttributeTuple]:
#         pass

# --------------------- new version --------------------------------


# class PropertiesNodeType(BoundedStringSet):
#     @strictly_typed
#     def __init__(self, prop_node_type: str) -> None:
#         super().__init__([['title'], ['splitter'], ['prop']], prop_node_type)
#
#
# class AppendNodeMethod(BoundedStringSet):
#     @strictly_typed
#     def __init__(self, prop_node_type: str) -> None:
#         super().__init__([['continue_chain'], ['to_splitter_value'], ['out_splitters']], prop_node_type)
#
#
# class PropertiesCreator:
#     def __init__(self):
#         self._base_graph = BasePolarGraph()
#         self._assoc = self.base_graph.associations
#         self._last_node = self.base_graph.inf_node_pu
#         self.assoc.register_association_types(PolarNode, {'node_type': 'PropertiesNodeType',
#                                                           'str_node_name': 'str',
#                                                           'str_node_values': 'list[str]'})
#         self.assoc.register_association_types(PGMove, {'splitter_value': 'str'})
#
#     @property
#     def base_graph(self):
#         return self._base_graph
#
#     @property
#     def assoc(self):
#         return self._assoc
#
#     @property
#     def last_node(self):
#         return self._last_node
#
#     def add_prop_node(self, str_node_name: str, str_node_values: list[str] = None,
#                       prop_node_type: PropertiesNodeType = None,
#                       append_method: AppendNodeMethod = None,
#                       connect_to_splitter_name_and_value: tuple[str, str] = None):
#         if not prop_node_type:
#             prop_node_type = PropertiesNodeType('prop')
#         if not append_method:
#             append_method = AppendNodeMethod('continue_chain')
#         bg = self.base_graph
#         assoc = self.assoc
#         prop_node: Optional[PolarNode] = None
#         if append_method == 'continue_chain':
#             ni_nd = self.last_node.ni_nd
#             prop_node, _, _ = bg.insert_node_single_link(ni_nd, bg.inf_node_nd.ni_pu)
#         elif append_method == 'out_splitters':
#             prop_node = bg.insert_node_neck(bg.inf_node_nd.ni_pu)
#         elif append_method == 'to_splitter_value':
#             assert connect_to_splitter_name_and_value, 'Splitter value should be specified'
#             spl_name, spl_value = connect_to_splitter_name_and_value
#             spl: PolarNode = assoc.get_element_by_content_value(PolarNode,
#                                                                 {'node_type': PropertiesNodeType('splitter'),
#                                                                  'str_node_name': spl_name})
#             assert spl, 'Splitter not found'
#             assert spl_value in spl.associations['str_node_values'], 'Splitter value not found'
#             ni_nd = spl.ni_nd
#             prop_node, pu_link, _ = bg.insert_node_single_link(ni_nd, bg.inf_node_nd.ni_pu)
#             move: PGMove = ni_nd.get_move(pu_link)  # 'splitter_value'
#             move.associations['splitter_value'] = spl_value
#
#         prop_node.associations['node_type'] = prop_node_type
#         prop_node.associations['str_node_name'] = str_node_name
#         prop_node.associations['str_node_values'] = str_node_values
#
#         self._last_node = prop_node

# --------------------  Assoc manager --------------
    # @strictly_typed
    # def get_all_elm_cells(self, element: Union[PolarNode, PGLink, PGMove]) -> Optional[set[TypedCell]]:
    #     if element not in self.cells:
    #         return
    #     cells = set()
    #     for _, val in self.cells[element].values():
    #         cells.add(val)
    #     return cells

    # @strictly_typed
    # def get_all_elms_by_cell_content(self, element_type: Type[Union[PolarNode, PGLink, PGMove]],
    #                                  key_function: Callable,
    #                                  context: str,
    #                                  given_elements: Optional[Iterable[Union[PolarNode, PGLink, PGMove]]] = None) -> \
    #         Union[PolarNode, PGLink, PGMove]:
    #     pass
   #
    # @strictly_typed
    # def extract_sbg_content(self, extract_keys: dict[Type[Union[PolarNode, PGLink, PGMove]], Union[str, set[str]]],
    #                         subgraph: PolarGraph, ignore_empties: bool = True, expand_result: bool = True,
    #                         get_as_strings: bool = True) -> set[Any]:
    #     result = set()
    #     types_storages = {PolarNode: subgraph.nodes, PGLink: subgraph.links, PGMove: subgraph.moves}
    #     for type_ in types_storages:
    #         if type_ in extract_keys:
    #             for element in types_storages[type_]:
    #                 element_result = set()
    #                 keys_for_extraction = extract_keys[type_]
    #                 if type(keys_for_extraction) == str:
    #                     keys_for_extraction = {keys_for_extraction}
    #                 for key in keys_for_extraction:
    #                     if not (element.associations[key] is None):
    #                         element_result.add(element.associations[key])
    #                 if ignore_empties and not element_result:
    #                     continue
    #                 if expand_result:
    #                     assert len(element_result) <= 1, 'Cannot expand result if several elements'
    #                     element_result = element_result.pop()
    #                 if get_as_strings:
    #                     element_result = str(element_result)
    #                 result.add(element_result)
    #     return result
    #

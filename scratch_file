
# class AttributeTuple:
#     def __init__(self, node_type, node_name, node_value):
#         self.node_type = node_type
#         self.node_name = node_name
#         self.node_value = node_value
#
#
# class AttributeNode(PolarNode):
#
#     @strictly_typed
#     def __init__(self, node_type: OneOfString(['title', 'splitter', 'value']), node_name: str = '',
#                  node_value: Any = None) -> None:
#         super().__init__()
#         self.content = AttributeTuple(node_type, node_name, node_value)
#
#     @property
#     def value(self):
#         return self.content.node_value
#
#     @value.setter
#     def value(self, val):
#         self.content.node_value = val
#
#
# class AttributeGraph(BasePolarGraph):
#
#     def __init__(self):
#         super().__init__()
#         self._splitters_last_nodes = []  # list[an]
#         self._associations = {}  # {(split_an, str_val): derived_an}
#
#     @strictly_typed
#     def associate(self, splitter_an: AttributeNode, splitter_str_value: str, derived_an: AttributeNode) -> None:
#         assert splitter_an in self._nodes, 'Splitter not found in nodes list'
#         assert splitter_an.content.node_type == 'splitter', 'Can be only splitter associated'
#         assert splitter_str_value in splitter_an.content.node_value, 'Splitter str-value not found in values list'
#         self._associations[(splitter_an, splitter_str_value)] = derived_an
#
#     @strictly_typed
#     def _add_node(self, an: AttributeNode, to_splitter: AttributeNode = None, associated_splitter_value: str = '',
#                   out_splitter: bool = False) -> None:
#         self._nodes.append(an)
#         if len(self._nodes) == 1:
#             return
#         last_node = self._nodes[-1]
#         if to_splitter:
#             assert to_splitter in self._nodes, 'Splitter not found in nodes'
#             if last_node != to_splitter:
#                 self._splitters_last_nodes.append(last_node)
#             an.connect_to_its_end(to_splitter)
#             self.associate(to_splitter, associated_splitter_value, an)
#         elif out_splitter:
#             for splitters_last_node in self._splitters_last_nodes:
#                 an.connect_to_its_end(splitters_last_node)
#             self._splitters_last_nodes.clear()
#         else:
#             an.connect_to_its_end(last_node)
#
#     @strictly_typed
#     def add_typed_node(self, node_type: OneOfString(['title', 'splitter', 'value']), node_name: str,
#                        to_splitter: AttributeNode = None, associated_splitter_value: str = '') -> None:
#         an = AttributeNode(node_type, node_name)
#         self._add_node(an, to_splitter, associated_splitter_value)
#
#     @strictly_typed
#     def set_node_value(self, value_name: str, value: Any) -> None:
#         node_found = False
#         for node in self._nodes:
#             if (node.content.node_type in ['value', 'splitter']) and (node.content.node_name == value_name):
#                 if node.content.node_type == 'splitter':
#                     assert isinstance(value, Iterable), 'Need iterable value for splitter'
#                     for val in value:
#                         assert type(val) == str, 'Values in splitter should be str'
#                 node.content.node_value = value
#                 return
#         assert node_found, 'Node for setting value is not found'
#
#     @strictly_typed
#     def last_splitter(self) -> Optional[AttributeNode]:
#         for node in reversed(self._nodes):
#             if node.content.node_type == 'splitter':
#                 return node
#
#     @strictly_typed
#     def switch_splitter(self, splitter_name: str, to_splitter_str_value: str) -> None:
#         node_found = False
#         for node in self._nodes:
#             if (node.content.node_type == 'splitter') and (node.content.node_name == splitter_name):
#                 node_found = True
#                 node.switch_move_branch(self._associations[(node, to_splitter_str_value)])
#         assert node_found, 'Node for setting value is not found'
#
#     @strictly_typed
#     def get_linear_list(self) -> list[AttributeTuple]:
#         pass

# --------------------- new version --------------------------------


# class PropertiesNodeType(BoundedStringSet):
#     @strictly_typed
#     def __init__(self, prop_node_type: str) -> None:
#         super().__init__([['title'], ['splitter'], ['prop']], prop_node_type)
#
#
# class AppendNodeMethod(BoundedStringSet):
#     @strictly_typed
#     def __init__(self, prop_node_type: str) -> None:
#         super().__init__([['continue_chain'], ['to_splitter_value'], ['out_splitters']], prop_node_type)
#
#
# class PropertiesCreator:
#     def __init__(self):
#         self._base_graph = BasePolarGraph()
#         self._assoc = self.base_graph.associations
#         self._last_node = self.base_graph.inf_node_pu
#         self.assoc.register_association_types(PolarNode, {'node_type': 'PropertiesNodeType',
#                                                           'str_node_name': 'str',
#                                                           'str_node_values': 'list[str]'})
#         self.assoc.register_association_types(PGMove, {'splitter_value': 'str'})
#
#     @property
#     def base_graph(self):
#         return self._base_graph
#
#     @property
#     def assoc(self):
#         return self._assoc
#
#     @property
#     def last_node(self):
#         return self._last_node
#
#     def add_prop_node(self, str_node_name: str, str_node_values: list[str] = None,
#                       prop_node_type: PropertiesNodeType = None,
#                       append_method: AppendNodeMethod = None,
#                       connect_to_splitter_name_and_value: tuple[str, str] = None):
#         if not prop_node_type:
#             prop_node_type = PropertiesNodeType('prop')
#         if not append_method:
#             append_method = AppendNodeMethod('continue_chain')
#         bg = self.base_graph
#         assoc = self.assoc
#         prop_node: Optional[PolarNode] = None
#         if append_method == 'continue_chain':
#             ni_nd = self.last_node.ni_nd
#             prop_node, _, _ = bg.insert_node_single_link(ni_nd, bg.inf_node_nd.ni_pu)
#         elif append_method == 'out_splitters':
#             prop_node = bg.insert_node_neck(bg.inf_node_nd.ni_pu)
#         elif append_method == 'to_splitter_value':
#             assert connect_to_splitter_name_and_value, 'Splitter value should be specified'
#             spl_name, spl_value = connect_to_splitter_name_and_value
#             spl: PolarNode = assoc.get_element_by_content_value(PolarNode,
#                                                                 {'node_type': PropertiesNodeType('splitter'),
#                                                                  'str_node_name': spl_name})
#             assert spl, 'Splitter not found'
#             assert spl_value in spl.associations['str_node_values'], 'Splitter value not found'
#             ni_nd = spl.ni_nd
#             prop_node, pu_link, _ = bg.insert_node_single_link(ni_nd, bg.inf_node_nd.ni_pu)
#             move: PGMove = ni_nd.get_move(pu_link)  # 'splitter_value'
#             move.associations['splitter_value'] = spl_value
#
#         prop_node.associations['node_type'] = prop_node_type
#         prop_node.associations['str_node_name'] = str_node_name
#         prop_node.associations['str_node_values'] = str_node_values
#
#         self._last_node = prop_node

# --------------------  Assoc manager --------------
    # @strictly_typed
    # def get_all_elm_cells(self, element: Union[PolarNode, PGLink, PGMove]) -> Optional[set[TypedCell]]:
    #     if element not in self.cells:
    #         return
    #     cells = set()
    #     for _, val in self.cells[element].values():
    #         cells.add(val)
    #     return cells

    # @strictly_typed
    # def get_all_elms_by_cell_content(self, element_type: Type[Union[PolarNode, PGLink, PGMove]],
    #                                  key_function: Callable,
    #                                  context: str,
    #                                  given_elements: Optional[Iterable[Union[PolarNode, PGLink, PGMove]]] = None) -> \
    #         Union[PolarNode, PGLink, PGMove]:
    #     pass
   #
    # @strictly_typed
    # def extract_sbg_content(self, extract_keys: dict[Type[Union[PolarNode, PGLink, PGMove]], Union[str, set[str]]],
    #                         subgraph: PolarGraph, ignore_empties: bool = True, expand_result: bool = True,
    #                         get_as_strings: bool = True) -> set[Any]:
    #     result = set()
    #     types_storages = {PolarNode: subgraph.nodes, PGLink: subgraph.links, PGMove: subgraph.moves}
    #     for type_ in types_storages:
    #         if type_ in extract_keys:
    #             for element in types_storages[type_]:
    #                 element_result = set()
    #                 keys_for_extraction = extract_keys[type_]
    #                 if type(keys_for_extraction) == str:
    #                     keys_for_extraction = {keys_for_extraction}
    #                 for key in keys_for_extraction:
    #                     if not (element.associations[key] is None):
    #                         element_result.add(element.associations[key])
    #                 if ignore_empties and not element_result:
    #                     continue
    #                 if expand_result:
    #                     assert len(element_result) <= 1, 'Cannot expand result if several elements'
    #                     element_result = element_result.pop()
    #                 if get_as_strings:
    #                     element_result = str(element_result)
    #                 result.add(element_result)
    #     return result
    #
    # ---------------------------- PGGraphMovesState -----------------------

#    class PGGraphMovesState:
#
#     @strictly_typed
#     def __init__(self, pg: BasePolarGraph) -> None:
#         self._moves: list[PGMove] = []
#         self.save_state(pg)
#
#     @strictly_typed
#     def save_state(self, pg: BasePolarGraph) -> None:
#         for pn in pg.nodes:
#             ni_nd, ni_pu = pn.ni_nd, pn.ni_pu
#             nd_active_move, pu_active_move = ni_nd.active_move, ni_pu.active_move
#             if nd_active_move:
#                 self._moves.append(ni_nd.active_move)
#             if pu_active_move:
#                 self._moves.append(ni_pu.active_move)
#
#     @strictly_typed
#     def reset_state(self) -> None:
#         for move in self._moves:
#             move.ni.choice_move_activate(move)

# ---------------------------------- str to obj ------------------------

# @strictly_typed
# def str_to_obj(str_value: str, req_cls_str: str) -> tuple[Any, bool]:
#     success = True
#
#     if not str_value or str_value.isspace():
#         return None, success
#
#     req_cls = get_class_by_str(req_cls_str)
#
#     if req_cls == str:
#         return str_value, success
#
#     if req_cls and issubclass(req_cls, BoundedStringSet):
#         if str_value in req_cls.possible_strings:
#             return req_cls(str_value), success
#         else:
#             return str_value, not success
#
#     str_with_replaced_id = str_value
#     found_identifier_candidates = re.findall(r'\w+', str_value)
#     for fic in found_identifier_candidates:
#         if fic in GNM.name_to_obj:
#             str_with_replaced_id = str_with_replaced_id.replace(fic, 'GNM.name_to_obj["{}"]'.format(fic))
#     try:
#         obj = eval(str_with_replaced_id)
#     except NameError:
#         return str_value, not success
#     else:
#         if type_verification(req_cls_str, obj):
#             return obj, success
#         else:
#             return str_value, not success
#
#
# def obj_to_str(obj) -> str:
#     if obj is None:
#         return ''
#
#     if type(obj) == type:
#         return obj.__name__
#
#     return str(obj)

# ----------------------  edit focus ----------

# value_wgt_0.ed
# value_wgt_0.setValidator(AlwaysTrueValidator())
# print('valid', value_wgt_0.validator())
# value_wgt_0.focusOutEvent.connect(self.edit_finished)
# value_wgt_0.editingFinished.connect(self.edit_finished)

from PyQt5.QtGui import QValidator
class AlwaysTrueValidator(QValidator):
    def validate(self, s: str = '', i: int = 0):
        return QValidator.Acceptable

# ----------------------  line_edit  ----------

    # def get_line_edit(self, str_name: str) -> QLineEdit:
    #     for line_edit_widget, label_widget in self.widgets_dict.items():
    #         if label_widget.text() == str_name:
    #             return line_edit_widget
    #     print('Not found')
    #     assert False, 'Not found'
    #
    # def replace_line_edit(self, af: AttributeFormat):
    #     str_name = af.attr_name
    #     old_le = self.get_line_edit(str_name)
    #     new_le = QLineEdit(af.attr_value, self)
    #     self.set_bool_color(new_le, af)
    #     self.main_layout.replaceWidget(old_le, new_le)
    #     self.widgets_dict[new_le] = self.widgets_dict[old_le]
    #     self.widgets_dict.pop(old_le)
    #     old_le.setParent(None)

    # @pyqtSlot(AttributeFormat)
    # def replace_line_edit(self, af: AttributeFormat):
    #     self.attributes_column.replace_line_edit(af)

# ------------------------------------ NameDescriptor --------------------

# class NameDescriptor:
#
#     def __init__(self, start_index=1):
#         assert type(start_index) == int, 'Start index must be int'
#         self.start_index = start_index
#
#     def __get__(self, instance, owner=None):
#
#         if not (instance is None) and not hasattr(instance, '_name'):
#             instance._name = None
#
#         if instance is None:
#             return owner.__name__
#         else:
#             if not (instance._name is None):
#                 return instance._name
#             else:
#                 raise ValueError('Name is not defined')
#
#     def __set__(self, instance, name_candidate):
#         if hasattr(instance, '_name'):
#             GNM.remove_obj_name(instance)
#         prefix = instance.__class__.__name__ + '_'
#         if name_candidate == 'auto_name':
#             i = self.start_index
#             while True:
#                 if i < 1:
#                     name_candidate = '{}{}'.format(prefix, '0' * (1 - i))
#                 else:
#                     name_candidate = '{}{}'.format(prefix, i)
#                 if GNM.check_new_name(name_candidate):
#                     break
#                 else:
#                     i += 1
#         else:
#             assert type(name_candidate) == str, 'Name need be str'
#             assert bool(re.fullmatch(r'\w+', name_candidate)), 'Name have to consists of alphas, nums and _'
#             assert name_candidate.startswith(prefix), 'Name have to begin from className_'
#             assert name_candidate != prefix, 'name cannot be == prefix; add specification to end'
#             assert not name_candidate[
#                        len(prefix):].isdigit(), 'Not auto-name cannot be (prefix + int); choose other name'
#             assert GNM.check_new_name(name_candidate), 'Name {} already exists'.format(name_candidate)
#         instance._name = name_candidate
#         GNM.register_obj_name(instance, name_candidate)

# -------------------- From Cell ------------

# def default_syntax_checker(value: str) -> Any:
#     value_got = value
#     found_identifier_candidates = re.findall(r'\w+', value)
#     for fic in found_identifier_candidates:
#         if fic in GNM.name_to_obj:
#             value = value.replace(fic, 'GNM.name_to_obj["{}"]'.format(fic))
#     try:
#         eval_result = eval(value)
#     except SyntaxError:
#         raise SyntaxCellError('Syntax error when parsing ' + value_got)
#     except NameError:
#         raise SyntaxCellError('Name error when parsing ' + value_got)
#     else:
#         return eval_result
#
#
# def splitter_syntax_checker(value: str, cls: type):
#     if value not in cls.possible_strings:
#         raise SyntaxCellError('Value of splitter not in possible values{}'.format(cls.possible_strings))
#     return value
#
#
# def bool_syntax_checker(value: str, cls: type):
#     if value not in cls.possible_strings:
#         raise SyntaxCellError('Value of splitter not in possible values {}'.format(cls.possible_strings))
#     return eval(value)
#
#
# def name_syntax_checker(value: str, obj: Any) -> str:
#     cls = obj.__class__
#     if (obj in GNM.obj_to_name) and (value == GNM.obj_to_name[obj]):
#         return value
#     prefix = cls.__name__ + '_'
#     if not re.fullmatch(r'\w+', value):
#         raise SyntaxCellError('Name have to consists of alphas, nums and _')
#     if not value.startswith(prefix):
#         raise SyntaxCellError('Name have to begin from ClassName_')
#     if value == prefix:
#         raise SyntaxCellError('Name cannot be == prefix; add specification to end')
#     if not GNM.check_new_name(value):
#         raise SyntaxCellError('Name {} already exists'.format(value))
#     return value
#
#
# def default_type_checker(value: Any, req_cls_str: str) -> None:
#     if not type_verification(req_cls_str, value):
#         raise TypeCellError('Given str_value type is not equal to required type')


# class CellChecker:
#     def __init__(self, f_check_syntax=None, f_check_type=None, f_check_semantic_list: list = None):
#         self.f_check_syntax = f_check_syntax
#         self.f_check_type = f_check_type
#         if f_check_semantic_list is None:
#             self.f_check_semantic_list = []
#         else:
#             self.f_check_semantic_list = f_check_semantic_list
#         self._req_class_str = None
#
#     def add_semantic_checker(self, f_check_semantic: Callable):
#         self.f_check_semantic_list.append(f_check_semantic)
#
#     def check_value(self, str_value: str):
#         result = None
#         if self.f_check_syntax:
#             result = self.f_check_syntax(str_value)
#         if self.f_check_type:
#             self.f_check_type(result)
#         for f_check_semantic in self.f_check_semantic_list:
#             f_check_semantic(str_value, result)
#         return result
#
#     @property
#     def req_class_str(self):
#         return self._req_class_str
#
#
# class NameCellChecker(CellChecker):
#     def __init__(self, obj: Any):
#         super().__init__(partial(name_syntax_checker, obj=obj))
#         self._req_class_str = 'str'  # .format(cls.__name__)
#
#
# class SplitterCellChecker(CellChecker):
#     def __init__(self, cls: type):
#         super().__init__(partial(splitter_syntax_checker, cls=cls))
#         self._req_class_str = cls.__name__
#
#
# class BoolCellChecker(CellChecker):
#     def __init__(self, cls: type):
#         super().__init__(partial(bool_syntax_checker, cls=cls))
#         self._req_class_str = cls.__name__
#
#
# class DefaultCellChecker(CellChecker):
#     def __init__(self, req_cls_str: str):
#         super().__init__(default_syntax_checker, partial(default_type_checker, req_cls_str=req_cls_str))
#         self._req_class_str = req_cls_str
#
#
# def name_auto_setter(cls: Any, start_index: int = 1):
#     prefix = cls.__name__ + '_'
#     i = start_index
#     while True:
#         if i < 1:
#             auto_name = '{}{}'.format(prefix, '0' * (1 - i))
#         else:
#             auto_name = '{}{}'.format(prefix, i)
#         if GNM.check_new_name(auto_name):
#             break
#         else:
#             i += 1
#     # print('In auto_name', auto_name)
#     return auto_name
#
#
# class AutoValueSetter:
#     def __init__(self, f_set_function=None):
#         self.f_set_function = f_set_function
#
#     def get_auto_value(self):  # , *args, **kwargs
#         return self.f_set_function()  # *args, **kwargs
#
#
# class NameAutoSetter(AutoValueSetter):
#     def __init__(self, cls: Any, start_index: int = 1):
#         super().__init__(partial(name_auto_setter, cls=cls, start_index=start_index))

        # self._is_suggested_value = False
        # self._str_value = val
        # if val == '':
        #     self._status_check = 'empty'


    # def activate(self):
    #     if self.str_value == '':
    #         self.auto_set_value()
    #     self._active = True
    #
    # def deactivate(self):
    #     self._active = False

    # @property
    # def checker(self):
    #     return self._checker
    #
    # @property
    # def auto_setter(self):
    #     return self._auto_setter


    # def check_value(self):
    #     if self.str_value == '':
    #         self._status_check = 'empty'
    #         self._value = None
    #         return
    #     if self.checker:
    #         try:
    #             result = self.checker.check_value(self.str_value)
    #         except CellError as ce:
    #             self._status_check = ce.args[0]
    #             self._value = None
    #         else:
    #             self._status_check = ''
    #             self._value = result
    #     else:
    #         self._status_check = ''
    #         self._value = self.str_value
    #
    # def auto_set_value(self):
    #     if self.auto_setter:
    #         self.str_value = self.auto_setter.get_auto_value()
    #         self.check_value()
    #         self._is_suggested_value = True

    # @property
    # def req_class_str(self):
    #     if self.checker:
    #         return self.checker.req_class_str


# if __name__ == '__main__':
#     class A:
#         pass


    a = A()
    # cc_1 = CellChecker(partial(name_syntax_checker, cls=A))
    # cc_2 = CellChecker(default_syntax_checker, partial(default_type_checker, req_cls_str='str'))
    # cc_1 = NameCellChecker(A)
    # cc_2 = DefaultCellChecker('int')
    # print(cc_1.check_value("A_r"))
    # print(cc_2.check_value("13"))
    # nas = NameAutoSetter(A)
    # GNM.register_obj_name('A_1', a)
    # print(nas.get_auto_value())

    # tc = TypedCell('tc', 'str', '13')
    # print(tc.__dict__)




